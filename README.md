# Down to Earth - Procedural Terrain Rendering with Real Landscapes

This project adapts the existing fractional Brownian Motion Algrotihm (fBM) to generate and render real-world terrains procedurally with OpenGL library. 

## How to build

*macOS*

Open terminal to the directory containing this repository.

```
cs312-Final-Project $ mkdir build
cs312-Final-Project $ cd build
cs312-Final-Project/build $ cmake ..
cs312-Final-Project/build $ make
```

To run each program from build, you would type

```
cs312-Final-Project/build $ ../bin/main
cs312-Final-Project/build $ ../bin/terrain-fbm
```
The `main` program shows the final result of the project and the `terrain-fbm` program generates a terrain with the classic fBM algorithm (rendered by the diffuse model).

## Features and Background Algorithms

### Heightmap generation

A *heightmap* is a float matrix (usually stored as an rgb image) whose entires specify the height at each point of a terrain. The existing online demos for heightmap generation either rely on creating a noise texture with a third-party application in advance (then import for rendering) or applying the midpoint displacement algorithm for the heightmap generation. Some recent works in academia introduce the classic fractional Brownian Motion Algorithm (fBM) and they result in some fractal landscapes that are random but self-similar.

### Classic fractional Brownian Motion Algorithm
A Brownian Motion (BM) is a movement of an object with random increments. In other words, it is a integral of white noises so that the result paths are random yet self-similar, i.e. a zoomed-in version of the path resembles the whole path. The usual way to implementing BM in computer science is to start with some periodic base function such as f(x) = sin(x). As we add several more sine functions with different amplitudes and frequencies (so-called noises), it results in a random path that becomes a fractal if we allowed the loop to continue forever.


A fractional Brownian Motion is a Brownian Motion such that we reserve a memory to keep track of the proess. In each iteration, the noise we add is based on the previous ones in terms of its frequency and amplitude. In other words, the increments are not completely independent from each other so that the result landscape is inherited with additional features. To control this process, we also keep a parameter `H` called the Hurst Exponent, ranging from 0 to 1. The precise algorithm for this increment process is shown below (gleaned from the codes).

```
inline float fbm(vec2 x) {
    float v = 0.0;
    float a = 0.1;
    vec2 shift = vec2(100.0f);
    // Rotate to reduce axial bias
    mat2 rot = mat2(cos(0.5f), sin(0.5f), -sin(0.5f), cos(0.5f));
    for (int i = 0; i < 8; ++i) {
        v += a * perlinNoise(x);
        x =  x * 2.0f + shift;
        a *= 0.5f;
    }
    return v;
}
```


When `H` gets larger, the memory is positively correlated so that changes in a given direction will tend to produce future changes in the same direction and the path will then be smoother than a vanilla BM. Oppositely, the landscape becomes more curvy than BM and results in a complex landscape. The following two pictures demonstrate the situations when `H` is 1 and 0.2 respectively (where the base noise function is `Perlin noise`), generated by the `terrain-fbm` program. It is rendered with the diffuse model.

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/h=1.png" />
</p>

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/h=02.png" />
</p>


### Adpated fractional Brownian Motion Algorithm
From pictures above, we note that a problem with the classic fBM algorithm is that the height varies too frequently as compared to most real-world terrains. In real world, we expect a terrain (e.g. of a national park resort) has more diverse landscapes such as mountains, grasslands, lakes, etc. In other words, there are places where the terrain is smoother than the ones generated by the fBM algorithm. To achieve this, we adapt the algorithm given in https://www.classes.cs.uchicago.edu/archive/2015/fall/23700-1/final-project/MusgraveTerrain00.pdf so that in the execution of fBM algorithm, we add a noise of lower frequencies to the local minima of the base function (the parameters are tuned specifically for this project). We also control the range of the noise function to be in [-1,1] so that the range for the output of the adapted fBM algorithm is [0,1]. This allows us to save the heightmap as a noise texture (.png file) locally and drastically improve the performance. To generate a new noise texture, please change the parameters (for fBM) in `main.h` and de-comment the following codes in `main.cpp`.

```
// generate noise here
    /*
    for (int i = 0; i < tex_size; i++){
        for (int j = 0; j < tex_size; j++){
            float h = hyrbidMultifractal(vec2((float)i/tex_size, (float)j/tex_size),  H, f, octaves, offset);
            if (h < 0){
                h = 0;
            }
            noise_tex.set_vec3(j, i, vec3(h, 0.0f, 0.0f));
        }
    }

    noise_tex.save("../textures/noise.png");
    */
```

The noise texture we generated for this project is presented below (where the r-value stores the height).

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/noise.png" />
</p>







The terrain generated by this texture (with `max_height = 12.0, size = 25.0`) is shown below (rendered with the diffuse model).

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/newefbm.png"/>
</p>

### Terrain generation

To generate a terrain from a height map, we generate a grid of a specified size in 3d space, where each vertex has height 0 in the beginning. Then, we load the heightmap onto the grid by locate each vertex in the map and assign the height accordingly. The grid is trianglated by tling with trangle stripes. This is done with `Grid.h` class and the generation algorithm is shown below.

```
for (int i = 0; i < lRes; i++){
      for (int j = 0; j < wRes; j++){
         GLfloat x = j/(float)(wRes-1);
         GLfloat y = i/(float)(lRes-1);
         GLfloat z = 0.0f;
         x = x * gridWidth - (gridWidth/2.0f);
         y = y * gridLength - (gridLength/2.0f);

         vertices[3 * i * wRes + 3 * j] = x;
         vertices[3 * i * wRes + 3 * j + 1] = y;
         vertices[3 * i * wRes + 3 * j + 2] = z;

         if (i+1 != wRes && j+1 < lRes){
            quads[6 * i * (wRes-1) + 6 * j] = i * wRes + j;
            quads[6 * i * (wRes-1) + 6 * j + 1] = i * wRes + j + wRes;
            quads[6 * i * (wRes-1) + 6 * j + 2] = i * wRes + j + wRes + 1;
            quads[6 * i * (wRes-1) + 6 * j + 3] = i * wRes + j;
            quads[6 * i * (wRes-1) + 6 * j + 4] = i * wRes + j + wRes + 1;
            quads[6 * i * (wRes-1) + 6 * j + 5] = i * wRes + j + 1;
         }
      }
   }

   mInitialized = true;
}
```


### Multitexture rendering

To render the terrain in a real-world style, we select different textures corresponding various heights of the terrain. For example, points above a height of 8.0 are rendered with snow texture, those between 3.5 and 8.0 are rendered with grass, those below 3.5 are rendered with sand. In real world, the land is often covered by a mixture of these textures (e.g. a grassland often has both both grass and rock/sand expose). To reflect this, we avoid using a pure texture of one kind. Instead, we produce some new textures by a linear interpolation of two or three. To make the transitions of these textures smooth (with respect to the height), we also use a linear interpolation of the textures for the mixing zones (e.g. height between 6.5 and 9.5). The algorithm is shown below.

```
	vec3 rockgrass = mix(grass, rock, coef);
    snow = mix(snow, rock, coef);
    vec3 snowgrass = mix(rockgrass, snow, coef);

    if (height > snow_height + mix_zone){
        kd = snow;
    } else if (height > snow_height - mix_zone) {
        float coef = (height-(snow_height - mix_zone))/(2.0 * mix_zone);
        kd = mix(snowgrass, snow, coef);
    } else if (height > grass_height + mix_zone){
        kd = snowgrass;
    } else if ( height > grass_height - mix_zone){
        float coef = (height-(grass_height - mix_zone))/(2.0 * mix_zone);
        kd = mix(sand, rockgrass, coef);
    } else {
        kd = sand;
    }
```

Some results of this feature are shown below. The texture and the rendering ideas are adapted from https://github.com/jadkhoury/ProceduralTerrain.

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/multitex.png"
</p>

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/multitex2.png"
</p>

### Fog and Sunlight effect

To mimic the real-world effect that it becomes harder to see clearly terrains/objects from a distance, we cast a fog effect by blurring the color of the terrain with respect to its distance from the camera. 

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/fog1.png" />
</p>

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/fog2.png" />
</p>

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/fog3.png" />
</p>

At the same time, the program keeps track of the position of sun light with a clock. The sun light starts at `(50.0, 0.0, 0.0)` and it revolves the origin `(0.0, 0.0, 0.0)` with a speeed of `0.7`. The motion/position is computed by applying a sine and cosine factor of the distance `50`. As the sunlight points towards the origin, the area of the terrain covered by the sunlight is "spotlighted" with an addition of the sunlight color (up: without sunlight; down: with sunlight).

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/nosunlight.png" />
</p>

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/sunlight.png" />
</p>

We also mimic the cycle of a day by rendering the terrain at night explicitly with a diffuse model. Then, with respect to the clock time, the actual color of the terrain is a linear interpolation of the morning rendering (multitexture rendering) and the night rendering.

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/morning.png" />
</p>

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/evening.png" />
</p>

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/night.png" />
</p>

### Sky rendering

To render the sky, we use the cubemap texture that renders a prescribed space. Again, two different textures are chosen for day and night so that the result texture of the sky is the linear interpolation of the two with respect to time.

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/terrainday.png" />
</p>

<p align="center">
  <img src="https://github.com/Jiajie-Ma/cs312-Final-Project/blob/main/images/terrainnight.png" />
</p>


### Cursor control

Left-drag orbits the camera around the terrain; SHIFT-left drag zooms in and out. Note that there is some limitation of the orbit for better user's experience. For example, users are not able to turn the terrain upside down; when they are in the terrain (i.e. the camera is in the terrain), they are only allowed to zoom out for a certain distance to experience the environment within the terrain.

## Animation result
